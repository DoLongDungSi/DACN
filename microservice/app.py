from flask import Flask, request, jsonify
import pandas as pd
import sys
import os
import uuid
import subprocess
import traceback
import shutil

app = Flask(__name__)

# Thư mục tạm để lưu file khi chấm
TEMP_DIR = "/tmp/eval"
if not os.path.exists(TEMP_DIR):
    os.makedirs(TEMP_DIR)

@app.route('/evaluate', methods=['POST'])
def evaluate():
    run_dir = None
    try:
        # 1. Kiểm tra dữ liệu đầu vào
        if 'submission_file' not in request.files:
            return jsonify({'error': 'Missing submission_file'}), 400
        if 'ground_truth_file' not in request.files:
            return jsonify({'error': 'Missing ground_truth_file'}), 400
        
        # Script có thể là file hoặc text. Ưu tiên text nếu backend gửi text.
        eval_script_content = request.form.get('evaluation_script')
        
        submission_file = request.files['submission_file']
        ground_truth_file = request.files['ground_truth_file']

        # 2. Tạo ID duy nhất cho lần chấm này để tránh xung đột file
        run_id = str(uuid.uuid4())
        run_dir = os.path.join(TEMP_DIR, run_id)
        os.makedirs(run_dir, exist_ok=True)

        sub_path = os.path.join(run_dir, "submission.csv")
        gt_path = os.path.join(run_dir, "ground_truth.csv")
        script_path = os.path.join(run_dir, "evaluate.py")
        output_path = os.path.join(run_dir, "score.txt")

        # 3. Lưu file xuống đĩa
        submission_file.save(sub_path)
        ground_truth_file.save(gt_path)

        if eval_script_content and eval_script_content.strip():
            with open(script_path, 'w') as f:
                f.write(eval_script_content)
        else:
            # Fallback nếu không có script custom: Dùng Accuracy mặc định
            # LƯU Ý QUAN TRỌNG: Backend gọi script với thứ tự:
            # argv[1]: submission, argv[2]: ground_truth, argv[3]: dummy, argv[4]: output_path
            default_script = """
import sys
import pandas as pd
from sklearn.metrics import accuracy_score

def evaluate(sub_path, gt_path, out_path):
    try:
        sub = pd.read_csv(sub_path)
        gt = pd.read_csv(gt_path)
        
        # Giả sử cột target là cột cuối cùng
        y_pred = sub.iloc[:, -1]
        y_true = gt.iloc[:, -1]
        
        score = accuracy_score(y_true, y_pred)
        
        with open(out_path, 'w') as f: 
            f.write(str(score))
            
    except Exception as e:
        print(f"Error details: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    # Backend truyền 4 tham số, tham số thứ 4 (index 4) là đường dẫn file kết quả
    if len(sys.argv) < 5:
        print("Not enough arguments", file=sys.stderr)
        sys.exit(1)
        
    evaluate(sys.argv[1], sys.argv[2], sys.argv[4])
"""
            with open(script_path, 'w') as f:
                f.write(default_script)

        # 4. Chạy script chấm điểm trong môi trường cách ly (subprocess)
        # Lệnh gọi: python evaluate.py <sub_path> <gt_path> <fake_public_test_path> <output_path>
        cmd = [sys.executable, script_path, sub_path, gt_path, gt_path, output_path]
        
        # Timeout 60s để tránh treo
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)

        if result.returncode != 0:
            print(f"Script Error Stderr: {result.stderr}")
            return jsonify({'score': 0, 'error': f"Runtime Error: {result.stderr}"}), 200

        # 5. Đọc kết quả
        if os.path.exists(output_path):
            with open(output_path, 'r') as f:
                score_str = f.read().strip()
                try:
                    score = float(score_str)
                    return jsonify({'score': score, 'error': None})
                except ValueError:
                    return jsonify({'score': 0, 'error': f"Invalid score format: {score_str}"})
        else:
            return jsonify({'score': 0, 'error': "No output file generated by evaluation script"})

    except Exception as e:
        traceback.print_exc()
        return jsonify({'score': 0, 'error': str(e)}), 500
    finally:
        # Dọn dẹp file tạm
        if run_dir and os.path.exists(run_dir):
            try:
                shutil.rmtree(run_dir)
            except Exception as e:
                print(f"Error cleaning up {run_dir}: {e}")

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5002)